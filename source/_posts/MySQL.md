---
typora-root-url: C:\software\blog\source\images
---

# 1 MySQL 架构与历史

## 1.1 MySQL逻辑架构			

​	如果能在头脑中构建一副MySQL各组件之间如何协同工作的架构图，就会有助于深入理解MySQL服务器。图1-1展示了MySQL的逻辑架构图。

![timg](/timg.jpg)

​								图1-1  MySQL的逻辑架构图

​	最上层的服务并不是MySQL所独有的，大多数基于网络的客户端/服务器工具或服务器都有类似的架构。比如连接处理，授权认证，安全等等。

​	第二层架构是MySQL的核心服务功能，包括查询解析，分析，优化，缓存以及所有的内置函数（例如：日期，时间，数字和加密函数），所有跨存储引擎的功能都在这一层实现：过程存储，触发器，视图等。

​	第三层包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。和GUN/Linux下的各种文件系统一样，每个存储引擎 都有它的优势和劣势。服务器通过API和存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些性差异对上从层的查询过程透明。存储引擎API包含了几十个底层函数，用于执行诸如“开始一个事务或者根据主键提取一个记录等操作。但存储引擎不会解析SQL,不同存储引擎之间也不会通信，而只是简单地相应服务器的请求。

# 5 创建高性能索引

## 5.1 索引基础

​	索引是存储引擎中用于快速找到记录的一种结构。在MySQL中，存储引擎现在索引中找到值，然后根据匹配的索引记录找到对应的数据行。索引可以包含一列或多个列的值。**MySQL只能高效的使用索引的最左前缀列。**创建一个包含两个列的索引和两个一列的索引大不相同。

###  5.1.1 索引的类型

​	在MySQL中，索引是在存储引擎层而不是服务层实现的。所以，不同存储引擎的索引工作方式不一样，同一类型的索引，在不同存储引擎中底层实现也可能不同。

**B-Tree 索引**

​	大多数MySQL引擎都支持这种索引。Archive引擎是一个例外。

## 5.2 索引的优点

​	索引可以让服务器快速地定位到表的指定位置。最常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。

​	1.索引大大减少了服务器需要扫描的数据量。

​	2.索引可以帮助服务器避免排序和临时表。

​	3.索引可以将随机I/O变为顺序I/O。

​	对于非常小的表，大部分情况下简单的全表扫描更高效。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价将随之增长。对于TB级别的数据，定位单条记录的意义不大，所以经常会使用块级别元素据技术来替代索引。

##5.3 高性能的索引策略

###5.3.1 独立的列

独立的列：指索引列不能是表达式的一部分，也不能是函数的参数。如果查询中的列不是独立的，MySQL就无法使用索引。如下面语句无法使用索引：

eg: select id from table1 where id+1=5;

### 5.3.2前缀索引和索引选择性

有时候需要索引很长的字符列，这会让索引变得大且慢。**通常可以索引字符开始的部分字符，这样可以大大节省索引空间，从而提高索引效率。但也会降低索引选择性。索引选择性是指，不重复的索引值（基数cardianlity)和数据库总记录数（#T)的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高**。因为选择性高的索引可以过滤更多的行，唯一索引的选择性是1 。这是最好的索引选择性，性能也是最好的。

一般情况下某个列的前缀选择性也是足够高的，足以满足查询要求。对于BLOB，TEXT或者很长的VAECHAR列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。

如何确定前缀索引长度：

1）查找最频繁出现的前缀，先从3个前缀字母开始

Select count(*) as cnt ,left(city,3) as pref from  table1 group by pref order by cnt desc limit 10;

2）每个前缀都比原来城市出现的次数多，因为唯一前缀要比唯一城市少的多，然后增加前缀长度。直到这个前缀的选择性接近完整列的选择性。

另一个方法是计算完整列的选择性，并使前缀的选择性接近与完整列的选择性。

计算完整列的选择性:

select count(distinct city)/count(*)  from table1 ;

select count(distinct left(city,3))/count(*) as sel3,

count(distinct left(city,4))/count(*) as sel4,

count(distinct left(city,5))/count(*) as sel5,

count(distinct left(city,6))/count(*) as sel6,

count(distinct left(city,7))/count(*) as sel7 from table1;

只看平均选择性是不够的，需要考虑最坏情况下的选择性。如果数据分布不均匀，可能是陷阱。

3)创建索引：ALTER TABLE table1 add key(city(7));

前缀索引是一种能是索引更小，更快的有效方法，缺点是：MySQL无法使用前缀索引做ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。常见应用场景是针对很长的十六进制唯一ID使用前缀索引。

### 5.3.3 多列索引

一个常见的错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。在多了个列上创建独立的单独索引大部分情况下并不能提高MySQL的查询性能。5.0和更新版本引入了一种叫"索引合并（index merge)"的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。OR条件的联合（union)，AND条件的相交（intersection），组合前两种情况的联合及相交。

**EXPlAIN** select film_id ,actor_id from table2 where actor_id =1 or film_id = 1\g

Using union(Primary,idx_fk_film_id)  ; type:index_merge；

MySQL会使用这类技术优化查询，索引合并策略有时候是一种优化的结果。

当出现服务器对多个索引相交操作时（and),通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引；当服务器需要对多个索引做联合操作（or)，通常需要消耗大量的CPU和内存资源在算法的缓存，排序和合并操作上。更重要的时优化器不会把这些计算到查询成本中。

### 5.3.4 选择合适的索引列顺序

正确的顺序依赖与使用该索引的查询，并且同时需要考虑如何更好的满足排序和分组的需要（本节适用B_TRee索引）。在一个多列B_TREE索引中，索引列的顺序意味着首先按照最左列进行排序，其次是第二列等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY，GROUP BY 和DISTINCT等子句的查询需求。

如何选择索引的列顺序经验法则：将选择性最高的列放到索引最前列。当不需要考虑排序和分组时，将选择性最好的列放在前面通常是最好的，这时候索引只用于优化where条件的查询。然而性能不只是依赖与所有索引的选择性，也和查询条件的具体值有关，也就是和值的分布有关。

以下面的查询为例：

select * from payment where staff_id = 2 and costom_id = 587;可以跑一些查询来确定在这个表中值的分布情况，并确定哪个列的选择性更高。先用下面的查询预测下，看看各个WHERE条件的分支对应的数据基数有多大

SELECT sum(staff_id=2),sum(customer_id=587) from payment;

 sum(staff_id=2)：7992

sum(customer_id=587) ：30

根据前面的法则应选择coutomer_id，在看看对应的staff_id的选择性如何

select sum(staff_id = 2) from payment where customer_id = 587;

最好还是按经验法则来做，因为经验法则考虑的是全局基数和选择性，而不是某个具体查询：

select count(distinct staff_id)/count(\*) as sele1,count(distinct customer_id)/count(\*) as sele2,count(*) from payment 。customer_id的选择性最高，所以作为索引的第一列。

ALTER TABLE payment add  key(customer_id,staff_id);













